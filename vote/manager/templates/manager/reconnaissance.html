<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="utf-8" />
  <title>Reconnaissance faciale ‚Äî capture unique</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f3f4f6;
      color: #222;
      padding: 20px;
    }

    .container {
      max-width: 980px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 18px;
    }

    video {
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    .controls {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      justify-content: center;
      align-items: center;
    }

    button {
      padding: 8px 14px;
      border-radius: 8px;
      border: 0;
      cursor: pointer;
      background: #0ea5a4;
      color: white;
    }

    button.secondary {
      background: #64748b;
    }

    .status {
      text-align: center;
      margin: 10px 0;
      font-weight: 600;
    }

    .result {
      margin-top: 20px;
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .card {
      background: white;
      padding: 12px;
      border-radius: 10px;
      box-shadow: 0 6px 18px rgba(2, 6, 23, 0.06);
      width: 320px;
      text-align: center;
    }

    .message.ok {
      color: green;
      font-weight: 700;
    }

    .message.bad {
      color: #c2410c;
      font-weight: 700;
    }

    .small {
      font-size: 13px;
      color: #555;
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>üîé Reconnaissance faciale ‚Äî capture unique</h1>
      <p class="small">Cliquez sur "Capturer & Envoyer" pour envoyer un seul frame au serveur.</p>

      {% if request.user.is_authenticated %}
      <div style="text-align:right; margin-top:8px;">
        <form action="{% url 'logout' %}" method="post" style="display:inline;">
          {% csrf_token %}
          <button type="submit" style="background:#c2410c;">D√©connexion</button>
        </form>
      </div>
      {% endif %}
    </header>

    <!-- Video preview -->
    <div style="display:flex; justify-content:center;">
      <video id="video" width="640" height="480" autoplay playsinline muted></video>
    </div>

    <div class="controls">
      <button id="startBtn" class="secondary">D√©marrer cam√©ra</button>
      <button id="stopBtn">Arr√™ter cam√©ra</button>
      <button id="captureBtn">Capturer & Envoyer</button>
    </div>

    <div style="min-width:220px; text-align:center; margin-top:10px;">
      <div id="status" class="status">Cam√©ra : attente...</div>
      <div class="small">Images pr√©charg√©es : <span id="preloaded-count">{{ preloaded_count }}</span></div>
    </div>

    <canvas id="canvas" width="640" height="480" style="display:none;"></canvas>

    <div class="result" id="resultContainer">
      {% if message %}
      <div class="card">
        <h4>R√©sultat initial</h4>
        <div id="initial-message" class="message {% if 'M√™me' in message %}ok{% else %}bad{% endif %}">{{ message }}
        </div>
        {% if similarity %}
        <p class="small">Similarit√© : {{ similarity|floatformat:3 }}</p>
        {% endif %}
        {% if uploaded_img_b64 %}
        <h4>Image envoy√©e</h4>
        <img src="{{ uploaded_img_b64 }}" alt="upload" style="max-width:280px;">
        {% endif %}
        {% if best_match %}
        <h4>Meilleur match</h4>
        <img src="{{ best_match.img_b64 }}" alt="{{ best_match.filename }}" style="max-width:280px;">
        <p class="small">{{ best_match.filename }}</p>
        {% endif %}
      </div>
      {% endif %}
    </div>
  </div>

  <script>
    /* utilitaires CSRF */
    function getCookie(name) {
      const v = document.cookie.split(';').map(c => c.trim()).find(c => c.startsWith(name + '='));
      if (!v) return null;
      return decodeURIComponent(v.split('=')[1]);
    }
    const csrftoken = getCookie('csrftoken');

    /* √©l√©ments */
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const statusEl = document.getElementById('status');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const captureBtn = document.getElementById('captureBtn');
    const resultContainer = document.getElementById('resultContainer');

    let stream = null;

    /* D√©marrer la cam√©ra */
    async function startCamera() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({video: {width: 640, height: 480}, audio: false});
        video.srcObject = stream;
        statusEl.textContent = "Cam√©ra pr√™te ‚úÖ";
      } catch (err) {
        console.error("Erreur acc√®s cam√©ra:", err);
        statusEl.textContent = "Erreur d'acc√®s cam√©ra ‚ùå";
      }
    }

    /* Arr√™ter la cam√©ra */
    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
        video.srcObject = null;
      }
      statusEl.textContent = "Cam√©ra arr√™t√©e";
    }

    /* Capture un frame et retourne un Blob JPEG */
    function captureFrameBlob() {
      const w = canvas.width;
      const h = canvas.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0, w, h);
      return new Promise((resolve) => canvas.toBlob((b) => resolve(b), 'image/jpeg', 0.9));
    }

    /* Envoi unique du frame vers la vue via fetch multipart/form-data */
    async function captureAndSend() {
      if (!stream) {
        statusEl.textContent = "Cam√©ra non initialis√©e";
        return;
      }
      statusEl.textContent = "Capture en cours...";
      try {
        const blob = await captureFrameBlob();
        if (!blob) {
          statusEl.textContent = "Erreur de capture";
          return;
        }

        const fd = new FormData();
        fd.append('image1', blob, 'frame.jpg');

        // Envoi au m√™me endpoint (la vue reconnaissance_view attend POST avec image1)
        const resp = await fetch(window.location.pathname, {
          method: 'POST',
          body: fd,
          headers: {
            'X-CSRFToken': csrftoken
          },
          credentials: 'same-origin',
          redirect: 'follow' // laisser suivre les redirect
        });

        // Si la vue a renvoy√© une redirection finale (ex: redirect('vote')),
        // fetch suit la redirection et resp.redirected devient true et resp.url la nouvelle URL.
        if (resp.redirected) {
          // rediriger le navigateur vers l'URL finale
          window.location.href = resp.url;
          return;
        }

        // Sinon on parse le HTML renvoy√© et on met √† jour la zone r√©sultat
        const text = await resp.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, 'text/html');

        const msgElem = doc.querySelector('#initial-message') || doc.querySelector('.message');
        const similarityElem = doc.querySelector('p.small') || null;
        const uploadedImg = doc.querySelector('img[alt="upload"]') || doc.querySelector('img[alt="Image upload√©e"]') || null;
        const bestMatchImg = doc.querySelector('img[alt^="Image match√©e"]') || doc.querySelector('.card img[alt]:not([alt="upload"])') || null;
        const bestMatchLabel = doc.querySelector('.card .small') || null;

        const block = document.createElement('div');
        block.className = 'card';

        const h = document.createElement('h4'); h.textContent = 'R√©sultat';
        block.appendChild(h);

        if (msgElem) {
          const m = document.createElement('div');
          const txt = msgElem.textContent.trim();
          m.id = 'initial-message-live';
          m.className = 'message ' + (txt.includes('M√™me') ? 'ok' : 'bad');
          m.textContent = txt;
          block.appendChild(m);
        }

        if (similarityElem) {
          const p = document.createElement('p');
          p.className = 'small';
          p.textContent = similarityElem.textContent.trim();
          block.appendChild(p);
        }

        if (uploadedImg) {
          const t = document.createElement('h4'); t.textContent = 'Image envoy√©e';
          block.appendChild(t);
          const img = document.createElement('img');
          img.src = uploadedImg.src;
          img.alt = 'upload';
          block.appendChild(img);
        }

        if (bestMatchImg) {
          const t2 = document.createElement('h4'); t2.textContent = 'Meilleur match';
          block.appendChild(t2);
          const img2 = document.createElement('img');
          img2.src = bestMatchImg.src;
          img2.alt = bestMatchImg.alt || 'match';
          block.appendChild(img2);
          if (bestMatchLabel) {
            const lbl = document.createElement('p');
            lbl.className = 'small';
            lbl.textContent = bestMatchLabel.textContent.trim();
            block.appendChild(lbl);
          }
        }

        resultContainer.innerHTML = '';
        resultContainer.appendChild(block);
        statusEl.textContent = '‚úÖ Envoi termin√©';

      } catch (err) {
        console.error('Erreur envoi:', err);
        statusEl.textContent = '‚ùå Erreur lors de l‚Äôenvoi';
      }
    }

    /* √©v√©nements */
    startBtn.addEventListener('click', async () => {if (!stream) await startCamera();});
    stopBtn.addEventListener('click', () => stopCamera());
    captureBtn.addEventListener('click', () => captureAndSend());

    /* initialisation auto (optionnel) */
    window.addEventListener('load', async () => {
      try {await startCamera();} catch (e) {console.warn('Impossible d\'init camera :', e);}
    });
  </script>
</body>

</html>
